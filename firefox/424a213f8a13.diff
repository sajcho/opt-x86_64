
# HG changeset patch
# User Mike Hommey <mh+mozilla@glandium.org>
# Date 1684442080 0
# Node ID 424a213f8a13af9e43cde21b7a70370433120869
# Parent  3436c899285c18d00293cf5c4b2703a9a355fce4
Bug 1831242 - Patch bindgen to work around issues with some unsound transmutes when compiling with LLVM 16+. r=supply-chain-reviewers, a=dmeehan

Differential Revision: https://phabricator.services.mozilla.com/D178251

diff --git a/Cargo.lock b/Cargo.lock
--- a/Cargo.lock
+++ b/Cargo.lock
@@ -418,18 +418,16 @@ name = "bindgen"
 version = "0.63.999"
 dependencies = [
  "bindgen 0.64.0",
 ]
 
 [[package]]
 name = "bindgen"
 version = "0.64.0"
-source = "registry+https://github.com/rust-lang/crates.io-index"
-checksum = "c4243e6031260db77ede97ad86c27e501d646a27ab57b59a574f725d98ab1fb4"
 dependencies = [
  "bitflags 1.3.2",
  "cexpr",
  "clang-sys",
  "lazy_static",
  "lazycell",
  "peeking_take_while",
  "proc-macro2",
diff --git a/Cargo.toml b/Cargo.toml
--- a/Cargo.toml
+++ b/Cargo.toml
@@ -117,17 +117,17 @@ tinyvec = { path = "build/rust/tinyvec" 
 
 # Patch base64 0.13 to 0.21
 base64 = { path = "build/rust/base64" }
 
 # Patch wasi 0.10 to 0.11
 wasi = { path = "build/rust/wasi" }
 
 # Patch bindgen 0.63 to 0.64
-bindgen = { path = "build/rust/bindgen" }
+bindgen_0_63 = { package = "bindgen", path = "build/rust/bindgen" }
 
 # Patch ntapi 0.3 to 0.4
 ntapi = { path = "build/rust/ntapi" }
 
 # Patch nix 0.24 to 0.26
 nix = { path = "build/rust/nix" }
 
 # Patch hermit-abi 0.1 to 0.2
@@ -140,16 +140,19 @@ autocfg = { path = "third_party/rust/aut
 # https://github.com/rust-lang/cargo/issues/6179
 js-sys = { path = "build/rust/dummy-web/js-sys" }
 wasm-bindgen = { path = "build/rust/dummy-web/wasm-bindgen" }
 web-sys = { path = "build/rust/dummy-web/web-sys" }
 
 # Overrides to allow easier use of common internal crates.
 moz_asserts = { path = "mozglue/static/rust/moz_asserts" }
 
+# Patch bindgen to work around issues with some unsound transmutes when compiling with LLVM 16+.
+bindgen = { path = "third_party/rust/bindgen" }
+
 # Patch `rure` to disable building the cdylib and staticlib targets
 # Cargo has no way to disable building targets your dependencies provide which
 # you don't depend on, and linking the cdylib breaks during instrumentation
 # builds.
 # Workaround for https://github.com/rust-lang/cargo/issues/11232
 rure = { path = "third_party/rust/rure" }
 
 # Other overrides
diff --git a/supply-chain/config.toml b/supply-chain/config.toml
--- a/supply-chain/config.toml
+++ b/supply-chain/config.toml
@@ -22,16 +22,20 @@ url = "https://raw.githubusercontent.com
 [policy.authenticator]
 audit-as-crates-io = true
 notes = "This is v0.4.0-alpha.14 plus upstream commit 2da9e991 to fix Bug 1824811."
 
 [policy.autocfg]
 audit-as-crates-io = true
 notes = "This is the upstream code plus a few local fixes, see bug 1685697."
 
+[policy."bindgen:0.64.0"]
+audit-as-crates-io = true
+notes = "This is a local override of the bindgen crate from crates.io, with a small local patch."
+
 [policy.chardetng]
 audit-as-crates-io = true
 notes = "This is a crate Henri wrote which is also published. We should probably update Firefox to tip and certify that."
 
 [policy.chardetng_c]
 audit-as-crates-io = true
 notes = "This is a crate Henri wrote which is also published. We should probably update Firefox to tip and certify that."
 
diff --git a/third_party/rust/bindgen/codegen/mod.rs b/third_party/rust/bindgen/codegen/mod.rs
--- a/third_party/rust/bindgen/codegen/mod.rs
+++ b/third_party/rust/bindgen/codegen/mod.rs
@@ -136,22 +136,23 @@ bitflags! {
         const EQ          = 1 << 8;
     }
 }
 
 fn derives_of_item(
     item: &Item,
     ctx: &BindgenContext,
     packed: bool,
+    forward_decl: bool,
 ) -> DerivableTraits {
     let mut derivable_traits = DerivableTraits::empty();
 
     let all_template_params = item.all_template_params(ctx);
 
-    if item.can_derive_copy(ctx) && !item.annotations().disallow_copy() {
+    if item.can_derive_copy(ctx) && !item.annotations().disallow_copy() && !forward_decl {
         derivable_traits |= DerivableTraits::COPY;
 
         if ctx.options().rust_features().builtin_clone_impls ||
             !all_template_params.is_empty()
         {
             // FIXME: This requires extra logic if you have a big array in a
             // templated struct. The reason for this is that the magic:
             //     fn clone(&self) -> Self { *self }
@@ -986,17 +987,17 @@ impl CodeGenerator for Type {
                             "repr_transparent feature is required to use {:?}",
                             alias_style
                         );
 
                         let mut attributes =
                             vec![attributes::repr("transparent")];
                         let packed = false; // Types can't be packed in Rust.
                         let derivable_traits =
-                            derives_of_item(item, ctx, packed);
+                            derives_of_item(item, ctx, packed, false);
                         if !derivable_traits.is_empty() {
                             let derives: Vec<_> = derivable_traits.into();
                             attributes.push(attributes::derives(&derives))
                         }
 
                         quote! {
                             #( #attributes )*
                             pub struct #rust_name
@@ -2027,18 +2028,19 @@ impl CodeGenerator for CompInfo {
                 let ty = helpers::blob(ctx, layout);
                 fields.push(quote! {
                     pub bindgen_union_field: #ty ,
                 })
             }
         }
 
         if forward_decl {
+            let prefix = ctx.trait_prefix();
             fields.push(quote! {
-                _unused: [u8; 0],
+                _unused: ::#prefix::cell::UnsafeCell<[u8; 0]>,
             });
         }
 
         let mut generic_param_names = vec![];
 
         for (idx, ty) in item.used_template_params(ctx).iter().enumerate() {
             let param = ctx.resolve_type(*ty);
             let name = param.name().unwrap();
@@ -2090,17 +2092,17 @@ impl CodeGenerator for CompInfo {
                 // presence of alignas.
                 let explicit = helpers::ast_ty::int_expr(explicit as i64);
                 attributes.push(quote! {
                     #[repr(align(#explicit))]
                 });
             }
         }
 
-        let derivable_traits = derives_of_item(item, ctx, packed);
+        let derivable_traits = derives_of_item(item, ctx, packed, self.is_forward_declaration());
         if !derivable_traits.contains(DerivableTraits::DEBUG) {
             needs_debug_impl = ctx.options().derive_debug &&
                 ctx.options().impl_debug &&
                 !ctx.no_debug_by_name(item) &&
                 !item.annotations().disallow_debug();
         }
 
         if !derivable_traits.contains(DerivableTraits::DEFAULT) {
@@ -3122,17 +3124,17 @@ impl CodeGenerator for Enum {
         }
 
         if item.must_use(ctx) {
             attrs.push(attributes::must_use());
         }
 
         if !variation.is_const() {
             let packed = false; // Enums can't be packed in Rust.
-            let mut derives = derives_of_item(item, ctx, packed);
+            let mut derives = derives_of_item(item, ctx, packed, false);
             // For backwards compat, enums always derive
             // Clone/Eq/PartialEq/Hash, even if we don't generate those by
             // default.
             derives.insert(
                 DerivableTraits::CLONE |
                     DerivableTraits::HASH |
                     DerivableTraits::PARTIAL_EQ |
                     DerivableTraits::EQ,

